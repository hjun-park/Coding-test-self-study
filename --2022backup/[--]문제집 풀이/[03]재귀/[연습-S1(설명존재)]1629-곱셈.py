import sys

sys.setrecursionlimit(10 ** 6)
input = sys.stdin.readline

'''
    [https://blog.encrypted.gg/943] 귀납적 사고
    우리가 평소에 생각하는 방식이 절차지향적 사고이다.
    ex) N부터 1까지 출력하는 문제를 생각할 때, N이 3이라면
      : 3출력 -> func1(2) 호출 -> 2출력 -> func(1) 호출 ... 이런 순이다.
      : 이는 flowchart로도 작성할 수 있다.
    
    하지만 재귀에서 생각하는 건 귀납적 사고이다.
    ex) 첫 번째로 func1(1)이 1을 출력한다. 그 다음 func1(2)는 2와 1을 출력한다.
    그렇게 본다면 func1(k)는 k, k-1, k-2 .. 1 을 출력한다.
     : 즉, func1(k)는 k, k-1, k-2 ... 1 을 출력한다. (참)
           func1(k+1)은 k+1, k, k-1, k-2 ... 1 을 출력한다. (참)
     : 이 두 문장이 모두 참이므로 func(1) 함수가 N부터 1까지 출력한다는 것을 알 수 있다.
     
     왜 올바른 결과를 내는지 과정을 하나하나 따라가는 것이 아니라
     귀납적인 사고를 통해서 이해한다.
     
     올바른 재귀함수라면 특정 입력에 대해서는 자기 자신을 호출하지 않는다. (종료부)
'''

'''
    문제에서는, 
    
    a^n x a^n = a^2n 이다.
    즉 12^58 === 4(mod67) -> 12^116 === 16(mod 67)
    
    여기서 알 수 있는 것은, 도미노를 귀납적 추론으로 본다면
     1) 1번 도미노가 쓰러진다.
     2) K번 도미노가 쓰러지면 K+1번 도미노도 쓰러진다.
    
    문제로 치환해보자면
     1) 1승을 계산할 수 있다.
     2) k승을 계산했으면 2k승과 2k+1승도 O(1) 복잡도로 계산이 가능하다.
    (2k+1 승은 2k승을 계산하고 a를 한 번만 곱해주면 2k+1승)
    
    즉, base condition(종료식)은 자기 자신이 나오는 b==1이고 이때는 a를 c로 나누면 된다.
    재귀식은 아래 코드 참고 

'''


def POW(a, b, m):
    # 1) 종료부
    if b == 1:
        return a % m

    # 2) 반복부
    val = POW(a, b // 2, m)
    val = val ** 2 % m

    # 3) b가 홀수였을 경우 2k+1니까 추가적으로 a를 더 곱해준다.
    if b % 2 == 0:
        return val
    else:
        return val * a % m


A, B, C = map(int, input().split())

print(POW(A, B, C))
