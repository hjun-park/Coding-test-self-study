# 시뮬레이션 문제 핵심 정리

### 1) 배경지식 NO, 구현력을 요구 
### 2) 구현이 어려울 수 있지만 꼭 구현해보자.
### 3) 직접 코드를 작성하고 제출하면서 맞왜틀 과정을 거쳐야 향상 가능

- - -

**기입할 점**

1) 어떻게 어떤 생각으로 문제를 접근하여 어떤 아이디어를 냈는가 ?
2) 특별히 어느 부분이 구현이 힘들었고 그건 어떻게 구현을 하였는가 ?
3) 나는 어떤 부분이 어려웠고 무엇을 배웠는가 ?

- - -

## [G5]15683-감시
1) 각 CCTV의 방향 선정
 - 모든 방향에 대해서 조합 만들기 가능
 - 다 확인하고싶은데 변수들끼리 서로 독립적인 경우 백트래킹보다는 진법 이용, 여기서는 4진법을 이용하면된다.
 - 만약 CCTV가 2개이면 4방향 x 4방향 = 16방향 즉, CCTV가 k개면 4^k이다.
 - 근데 CCTV가 2번 2개 혹은 5번이 1개라 하면 4^k보다 적은데 왜 4^k로 통일하지?
   - 어차피 중복되는 횟수가 있더라도 시간내로 여유롭게 통과되기 때문에 CCTV 종류 가리지 않고 4^k로 계산할 것이다.

2) 정한 방향에 대해서 사각지대 크기 구하기 (최솟값이 답)
 - 화살표를 따라가면서 벽을 만날 때 까지 진행하면서 지나치는 영역에 마킹한다.
 - 그 뒤에 마크가 없는 곳이 몇 개인지 세면 된다.

```python
import sys

input = sys.stdin.readline

N, M = map(int, input().split())

# 입력으로 주어지는 사무실의 모양
graph1 = [list(map(int, input().split())) for _ in range(N)]

# CCTV 방향 정한 후 CCTV 감시 영역에 걸리는 칸을 7로 마킹할 모양
graph2 = [[0] * M for _ in range(N)]

# cctv 좌표를 담을 변수
cctv = []

# 반시계방향
dx = [0, -1, 0, 1]
dy = [-1, 0, 1, 0]


# (x, y)에서 dir방향 진행하며 벽을 만날 때까지 지나가는 모든 빈 칸을 7로 변경함
def upd(x, y, dir):
    dir %= 4
    dir = int(dir)
    # 내가 기존에 했던 BFS 방식과 다르게 쭉 진행해야 하는 경우는 while True 사용
    while True:
        x += dx[dir]
        y += dy[dir]

        if (not 0 <= x < N or not 0 <= y < M) or graph2[x][y] == 6:  # 범위 안에 없거나 벽이 있다면
            return

        if graph2[x][y] != 0:  # CCTV가 있는 자리라면 continue
            continue

        graph2[x][y] = 7  # 지나가는 길 마킹


# ===================================
# 0. CCTV 추가
# ===================================
empty = 0
for i in range(N):
    for j in range(M):
        if graph1[i][j] != 0 and graph1[i][j] != 6:  # CCTV 라면
            cctv.append((i, j))
        if graph1[i][j] == 0:  # 빈 칸이라면
            empty += 1  # CCTV가 아예 없는 것도 고려해야하니, 빈칸의 개수로 맞추는게 안전

# ========================================
# 1. CCTV 방향 지정 (4진법 사용, 백트래킹보다 효율적)
# =======================================
for tmp in range(0, 1 << (2 * len(cctv))):  # CCTV 개수만큼 loop를 돈다.
    for i in range(0, N):
        for j in range(0, M):
            graph2[i][j] = graph1[i][j]  # upd 함수를 거치며 graph2가 변경됨
    brute = tmp
    for i in range(0, len(cctv)):
        dir = brute % 4
        brute /= 4

        x = cctv[i][0]
        y = cctv[i][1]

        # 1번 CCTV는 한 방향으로 upd 진행
        if graph1[x][y] == 1:
            upd(x, y, dir)

        # 2번 CCTV는 서로 마주보는 방향으로 진행
        elif graph1[x][y] == 2:
            upd(x, y, dir)
            upd(x, y, dir + 2)

        # 3번 CCTV는 직각이므로 dir, dir+1
        elif graph1[x][y] == 3:
            upd(x, y, dir)
            upd(x, y, dir + 1)

        # 4번 cctv는 세 방향
        elif graph1[x][y] == 4:
            upd(x, y, dir)
            upd(x, y, dir + 1)
            upd(x, y, dir + 2)

        # 5번 cctv는 네 방향
        else:
            upd(x, y, dir)
            upd(x, y, dir + 1)
            upd(x, y, dir + 2)
            upd(x, y, dir + 3)

        # ========================================
        # 2. 각 CCTV마다 가면서 마킹을 남기고 마킹이 없는 부분을 센다.
        # =======================================
        val = 0
        for i in range(N):
            for j in range(M):
                val += 1 if graph2[i][j] == 0 else 0
        empty = min(empty, val) # 가장 최솟값으로 갱신

print(empty)
```

- - -

## [G3]18808-스티커 붙이기
**필요한 절차**
1) 스티커를 특정 영역에 붙일 수 있는지 
   - 스티커를 붙일 수 있는지 확인 / 실제로 붙이는 작업
2) 스티커를 회전하기
   - 90도 회전을 모양 자체에 신경쓰기보다 수에서 규칙을 찾는다고 생각
   - B[x][y] = A[3-1-y][x] ==> 90도 회전
   - 2-y가 아니라 3-1-y로 쓴 이유는 3이 A의 처음 사이즈, 
   - 예시에는 A가 (2,3) 사이즈로 나와있지만 (r,c)사이즈라면,
   - B[x][y] = A[r-1-y][x]가 된다.
   - 그림 그리고 좌표 하나하나 써보고 돌리고 써보면 규칙 찾기 어렵지않다. (강의참고)






 
