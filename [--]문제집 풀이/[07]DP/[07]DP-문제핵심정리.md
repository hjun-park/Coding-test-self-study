# DP 문제 핵심 정리

### - 문제를 많이 풀다 보면 익혀지는 개념

### DP란

- 여러 개의 하위 문제를 먼저 푼 후 그 결과를 쌓아올려 주어진 문제 해결하는 알고리즘
- 즉, 문제해결 위한 점화식을 찾아낸 후 점화식의 항을 밑에서부터 차례로 구해나가서, 답을 알아내는 형태의 알고리즘
- ex) 피보나치

<br />

### DP를 푸는 과정

1) 테이블 정의
    - 특별한 공식이 없다. 경험적으로 익혀야 한다.
2) 점화식 찾기
3) 초기값 정하기

### 여담

- 일단 점화식만 찾고나면 그 뒤는 초기값을 채워넣은 후에
- 반복문을 돌면서 배열을 채워넣으면 끝이다.
- 그러나 처음에는 점화식 이끌어내는게 어렵고 DP문제라는 그 자체를 모를 수도 있다.

### 전략

- 괜찮은 문제들을 많이 풀어보자.
- DP 점화식 찾는게 너무 어렵다면, 처음 테이블을 정의하고 그 테이블을 직접 채우면서 규칙, 점화식을 찾는다.
- 개인차이지만 1부터 시작하는게 더 직관적이라면 0 패딩을 더 넣어주기

#### 점화식은 테이블 표를 정의하고 하나하나 채우다보면 규칙이 보인다.

- - -

**기입할 점**

1) 어떻게 어떤 생각으로 문제를 접근하여 어떤 아이디어를 냈는가 ?
2) 특별히 어느 부분이 구현이 힘들었고 그건 어떻게 구현을 하였는가 ?
3) 나는 어떤 부분이 어려웠고 무엇을 배웠는가 ?

- - -

## [연습-S3]1463-1로 만들기

DP를 푸는 과정

### 1) 테이블 정의

- D[i] = i를 1로 만들기 위해 필요한 연산 사용 횟수의 최솟값

### 2) 점화식 찾기 (예시)

- D[12] = ?
- D[12]를 구할 때 쯤이면 D[1] ... D[11] 최솟값은 이미 정해진 상태이다. 따라서,
- 3으로 나누거나 (D[12] = D[4] + 1)
- 2로 나누거나 (D[12] = D[6] + 1)
- 1을 빼거나 (D[12] = D[11] + 1)
- -> 여기서 봤을 때 D[4], D[6], D[11]은 이미 다 정해진 상태이므로
- ----> 점화식 D[12] = min(D[4]+1, D[6]+1, D[11]+1)

### 3) 점화식 찾기 (공통 수 k로)

- D[k] = ?
- 3으로 나누어지면 3으로 나누거나 (D[k] = D[k/3] + 1)
- 2로 나누어지면 2로 나누거나 (D[k] = D[k/2] + 1)
- 1로 빼거나 (D[k] = D[k-1] + 1) 이들 중에서 최솟값

### 4)) 초기값 정하기

- 피보나치에서 초항과 그 다음 항이 1, 1인 것처럼 초기값이 필요하다.
- 따라서 여기서도 초기값이 있어야 하며,
- D[1] = 0 이라는게 주어지면 나머지는 계산이 가능하다.

```python
import sys

input = sys.stdin.readline

N = int(input().rstrip())

# BFS로도 풀 수 있지만 DP가 더 간략하다.

d = [0] * (N + 1)  # D[어떤 수] = 연산최솟값
d[1] = 0  # 1인 경우 어떤 연산도 필요 없으므로 연산횟수 0

for i in range(2, N + 1):  # 초깃값 이후 계속 채워 나간다.
    # 1) 1로 뺸 결과 반영
    d[i] = d[i - 1] + 1  # 연산결과 반영된거이므로 연산횟수 증가해서 +1

    if i % 2 == 0:
        d[i] = min(d[i], d[i // 2] + 1)  # 1 뺀 것과 2로 나눈 것 중 최소 넣기

    if i % 3 == 0:
        d[i] = min(d[i], d[i // 3] + 1)  # 1뺀것과 3나눈것 중 최소 넣기

print(d[N])

```

- - -

## [S3]9095-1,2,3 더하기

```python
import sys

input = sys.stdin.readline

'''
 1) 테이블 정의
  - dp[i] = i를 1, 2, 3 의 합으로 나타내는 방법의 수 

 2) 점화식 찾기
  - 영상 참고 ( 이런데서도 이런 규칙을 만드는구나 ) 
  - d[4] = d[3] + d[2] + d[1]

 3) 규칙 만들기
 - d[k] = d[k-1] + d[k-2] + d[k-3]

 4) 초깃값 설정
  - d[1] = 1, d[2] = 2, d[3] = 4
'''

# 더 효율적인 방법은 구하고자 하는 가장 큰 n을 선정해서 거기까지 미리 다 구하는 것
for _ in range(int(input().rstrip())):
    n = int(input().rstrip())
    d = [0] * (n + 1)
    d[1] = 1
    d[2] = 2
    d[3] = 4

    for i in range(4, n + 1):
        d[i] = d[i - 1] + d[i - 2] + d[i - 3]

    print(d[n])

```

- - -

## [S3]2579-계단 오르기

- 점화식 구하는 방법을 잘 살펴본다.

```python
import sys

input = sys.stdin.readline

N = int(input().rstrip())
S = [0] + [int(input().rstrip()) for _ in range(N)]
'''
1) DP 테이블 정의
 D[i] = i번째 계단까지 올라섰을 때 점수 합의 최댓값

2) 점화식 세우기 - 연속된 세 계단을 밟지 않는다는 부분을 점화식 넣기 힘듦
 D[1] = 10
 D[2] = 20
 D[3] = 35

>> 그럴 경우 다시 테이블을 정의한다.

1) DP 테이블 정의
 D[i][j] = 현재까지 j개의 계단을 연속해서 밟고 i번째 계단에 올라섰을 때
           점수 합의 최댓값, 단, i번째 계단은 반드시 밟아야 함.
 - 2차원을 사용한 이유 : 지금까지 몇 개의 계단을 밟았는지 정보 제공 위헤
 - 그러니까 D[i][3]은 연속해서 3번 밟았으므로 이 경우는 올 수 없다.
 
2) 점화식 찾기
 D[k][1] : 현재까지 1개 계단 연속해서 밟고 K위치에 서 있을 때 점수 합 최댓값
 => 즉, 1개 계단을 연속해서 밟았다면 k-1 번째는 밟지 않음
 => 또한, k-1을 밟지 않았으므로 k-2번째는 밟았다. 
 => 점화식만 이끌어내는게 중요하므로 k-2 보다 그 아래 계단은 알아 볼 필요가 없다.
 
3) 점화식 채우기
 !! 그래서 점화식을 세워보면 (S배열은 계단 점수 배열)
 D[k][1] = max(D[k-2][1], D[k-2][2]) + S[k]
   => 어차피 k-1은 밟지 않았으므로 반영하지 않음
   => k-2를 밟은 것들 중 연속된계단이 1, 2개 모두 가능 
 D[k][2] = D[k-1][1] + S[k]
   => k-1번째 밟을 때 1개만 밟은 상태만 가능, [k-1][2]는 연속 3계단이라 안 된다. 
   => k번째 계단이 2번째로 밟은 계단이므로 k-2는 올 수 없다.
   
 4) 초기값 정하기
  -> 점화식에서 어디까지 참고하는지 생각하고 정하기
  D[1][1] = S[1] / D[1][2] = 0
  D[2][1] = S[2] / D[2][2] = S[1] + S[2]

'''

d = [[0 for _ in range(3)] for _ in range(N + 1)]
d[1][1] = S[1]
d[1][2] = 0  # 1개 올라왔는데 2계단 연속 밟을 리는 없으니까
d[2][1] = S[2]
d[2][2] = S[1] + S[2]

for k in range(3, N + 1):
    d[k][1] = max(d[k - 2][1], d[k - 2][2]) + S[k]
    d[k][2] = d[k - 1][1] + S[k]

print(max(d[N][1], d[N][2]))


```

- - -

## [S3]12852-1로 만들기 2

- 기존의 1로 만들기와는 다르게
- 1로 만드는 방법에 포함되어 있는 수도 출력해야함
- 즉, 1로 만들기 위해 거쳐온 과정들을 출력 => 따로 테이블에 담기

```python
import sys

input = sys.stdin.readline

N = int(input().rstrip())

d = [0] * 1000005
pre = [0] * 1000005

'''
  1463-1로 만들기와 다르게 거쳐온 과정도 함께 출력하라는 문제
   - 이 경우 2개의 테이블이 필요하다.
     1) 원래의 DP값 테이블 (D) 테이블
     2) 추가적인 테이블 (경로 복원용 pre) 테이블
        
            1   2   3   4   5   6   7   8  
      d =   0   1   2   2   3   2   3   3
    pre =   0   1   1   2   4   3   6   4
    
    --> d[3] = 2 (3에서 1로 만들기 위해 필요한 최적 연산은 2번)
    --> pre[3] = 1 (3에서 1로 가는게 최적이라는 의미)

'''

# 1) 테이블을 채워 넣어준다.
# 2와 3으로 나누어 떨어질 때는 -1을 뺀 것과 비교해서 2로 혹은 3으로 나눈게 더 최적이라면
# d[i]를 다시 정의해주고 pre[i]도 다시 정의한다.
for i in range(2, N + 1):
    d[i] = d[i - 1] + 1
    pre[i] = i - 1

    if i % 2 == 0 and d[i] > d[i // 2] + 1:
        d[i] = d[i // 2] + 1
        pre[i] = i // 2

    if i % 3 == 0 and d[i] > d[i // 3] + 1:
        d[i] = d[i // 3] + 1
        pre[i] = i // 3

print(d[N])
cur = N

# 2) 값을 얻은 경로가 필요한 상황이라면 내 값은 어디로부터 온 건가 확인하며 경로 복원
#  ==> 해당 경로는 전부 1로 만드는 방법에 포함되어 있음
while True:
    print(cur, end=' ')
    if cur == 1:
        break

    cur = pre[cur]

```

- - -

## [S2]1912-연속합

- 점화식 세워보는 연습 한 번 해보기

```python
import sys

input = sys.stdin.readline

n = int(input().rstrip())
nums = [0] + list(map(int, input().split()))
d = [0] * (n + 1)

'''
 1) 테이블 정의
 D[i] = 연속된 i개 선택된 수 중 가장 큰 합
 
 2) 점화식
 d[i] = max(d[i], d[i-1] + nums[i]) // 현재까지의 가장 큰 합과 이전까지 가장 큰 합 + 현재 숫자 비교
 
 3) 초기값
 d[i] = a[i]
'''

# 초기값  생성
for i in range(1, n + 1):
    d[i] = nums[i]

# 점화식
for i in range(1, n + 1):
    d[i] = max(d[i], d[i - 1] + nums[i])

# 1-index이므로 1부터 n까지
print(max(d[1:n + 1]))

```

- - -

## [S3]12852-1로 만들기 2
