import sys

input = sys.stdin.readline

N = int(input().rstrip())

# BFS로도 풀 수 있지만 DP가 더 간략하다.

'''
 DP를 푸는 과정 
 1) 테이블 정의
  - D[i] = i를 1로 만들기 위해 필요한 연산 사용 횟수의 최솟값
 2-1) 점화식 찾기 (예시)
  - D[12] = ?
  - D[12]를 구할 때 쯤이면 D[1] ... D[11] 최솟값은 이미 정해진 상태이다. 따라서,
  - 3으로 나누거나 (D[12] = D[4] + 1)
  - 2로 나누거나 (D[12] = D[6] + 1)
  - 1을 빼거나 (D[12] = D[11] + 1)
  --> 여기서 봤을 때 D[4], D[6], D[11]은 이미 다 정해진 상태이므로
  -----> 점화식 D[12] = min(D[4]+1, D[6]+1, D[11]+1)
 2-2) 점화식 찾기 (공통 수 k로)
  - D[k] = ?
  - 3으로 나누어지면 3으로 나누거나 (D[k] = D[k/3] + 1)
  - 2로 나누어지면 2로 나누거나 (D[k] = D[k/2] + 1)
  - 1로 빼거나 (D[k] = D[k-1] + 1) 이들 중에서 최솟값
  
 3) 초기값 정하기
  - 피보나치에서 초항과 그 다음 항이 1, 1인 것처럼 초기값이 필요하다.
  - 따라서 여기서도 초기값이 있어야 하며,
  - D[1] = 0 이라는게 주어지면 나머지는 계산이 가능하다. 
'''

d = [0] * (N + 1)  # D[어떤 수] = 연산최솟값
d[1] = 0  # 1인 경우 어떤 연산도 필요 없으므로 연산횟수 0

for i in range(2, N + 1):  # 초깃값 이후 계속 채워 나간다.
    # 1) 1로 뺸 결과 반영
    d[i] = d[i - 1] + 1  # 연산결과 반영된거이므로 연산횟수 증가해서 +1

    if i % 2 == 0:
        d[i] = min(d[i], d[i // 2] + 1)  # 1 뺀 것과 2로 나눈 것 중 최소 넣기

    if i % 3 == 0:
        d[i] = min(d[i], d[i // 3] + 1)  # 1뺀것과 3나눈것 중 최소 넣기

print(d[N])
