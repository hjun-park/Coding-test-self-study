import sys

input = sys.stdin.readline

N = int(input().rstrip())

S = [0] + [int(input().rstrip()) for _ in range(N)]

# 계단이 1개인 경우 처리
if N == 1:
    print(S[1])
    sys.exit(0)

'''
1) DP 테이블 정의
 D[i] = i번째 계단까지 올라섰을 때 점수 합의 최댓값

2) 점화식 세우기 - 연속된 세 계단을 밟지 않는다는 부분을 점화식 넣기 힘듦
 D[1] = 10
 D[2] = 20
 D[3] = 35

>> 그럴 경우 다시 테이블을 정의한다.

1) DP 테이블 정의
 D[i][j] = 현재까지 j개의 계단을 연속해서 밟고 i번째 계단에 올라섰을 때
           점수 합의 최댓값, 단, i번째 계단은 반드시 밟아야 함.
 - 2차원을 사용한 이유 : 지금까지 몇 개의 계단을 밟았는지 정보 제공 위헤
 - 그러니까 D[i][3]은 연속해서 3번 밟았으므로 이 경우는 올 수 없다.
 
2) 점화식 찾기
 D[k][1] : 현재까지 1개 계단 연속해서 밟고 K위치에 서 있을 때 점수 합 최댓값
 => 즉, 1개 계단을 연속해서 밟았다면 k-1 번째는 밟지 않음
 => 또한, k-1을 밟지 않았으므로 k-2번째는 밟았다. 
 => 점화식만 이끌어내는게 중요하므로 k-2 보다 그 아래 계단은 알아 볼 필요가 없다.
 
3) 점화식 채우기
 !! 그래서 점화식을 세워보면 (S배열은 계단 점수 배열)
 D[k][1] = max(D[k-2][1], D[k-2][2]) + S[k]
   => 어차피 k-1은 밟지 않았으므로 반영하지 않음
   => k-2를 밟은 것들 중 연속된계단이 1, 2개 모두 가능 
 D[k][2] = D[k-1][1] + S[k]
   => k-1번째 밟을 때 1개만 밟은 상태만 가능, [k-1][2]는 연속 3계단이라 안 된다. 
   => k번째 계단이 2번째로 밟은 계단이므로 k-2는 올 수 없다.
   
 4) 초기값 정하기
  -> 점화식에서 어디까지 참고하는지 생각하고 정하기
  D[1][1] = S[1] / D[1][2] = 0
  D[2][1] = S[2] / D[2][2] = S[1] + S[2]

'''

d = [[0 for _ in range(3)] for _ in range(N + 1)]
d[1][1] = S[1]
d[1][2] = 0  # 1개 올라왔는데 2계단 연속 밟을 리는 없으니까
d[2][1] = S[2]
d[2][2] = S[1] + S[2]

for k in range(3, N + 1):
    d[k][1] = max(d[k - 2][1], d[k - 2][2]) + S[k]
    d[k][2] = d[k - 1][1] + S[k]

print(max(d[N][1], d[N][2]))
