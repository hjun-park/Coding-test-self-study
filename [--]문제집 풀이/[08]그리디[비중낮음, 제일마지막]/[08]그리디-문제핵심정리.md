# 그리디 문제 핵심 정리

### 이상적인 문제 풀이 흐름

![image](https://user-images.githubusercontent.com/70880695/159196427-9cd719cb-f20a-4f74-a24c-ac9e3e9c5bdc.png)

- 직접적으로 풀 수 없을 때 시간복잡도를 낮추는 방법으로 생각
- 그러다 방법이 생각나면 올바른 결과를 낸다는 것을 수학적으로 증명
- 증명 이후 구현해서 문제 풀기

<br />

### But 현실적인 문제 풀이 흐름

![image](https://user-images.githubusercontent.com/70880695/159196496-09d0f8bb-2441-472c-ab71-9ea8a3e03416.png)

<br />

### 절망적인 문제 풀이 흐름

![image](https://user-images.githubusercontent.com/70880695/159196568-c8f27f2d-159e-4831-bfd2-8c8911c6cede.png)

- 잘못된 방법을 고안하면 풀이법을 잘못선택했는지 구현을 잘 못했는지 알 수 없음

<br />

### 실제 코딩테스트에서의 추천 전략

![image](https://user-images.githubusercontent.com/70880695/159196614-c1013f02-f211-458a-b72b-0a051e48a00e.png)

- 즉, 내가 풀어본 거면 풀이 시도
- 내가 풀어보지 않았다면 시도하지 말고 손절 (확신 안 되어도 풀지말 것)
- 틀린 경우 확인하는데 시간이 엄청 걸림

<br />

### 잘못된 그리디

- 부작용: 그리디로 풀 수 없는 문제임에 불구하고 일단 그리디로 질러봄
- 그리디로 될 것 같지만 반례가 있는 문제 (12865-평범한 배낭)

### 정리

- 그리디인걸 알고 푸는 것과 모르고 푸는 것은 차이가 많이 크다.
- 그래서 백준에서 구현을 막 풀다가 중간에 그리디가 얻어 걸려야 많이 배운다.
- 코테에서 가장 중요한 것은 `그리디로 못 푸는 것`보다
- 오히려 `그리디로 푸는 문제가 아닌데 그리디로 풀 수 있다고 착각하는` 경우를 더 조심해야함.
- 그리디에 시간을 많이 담지 말자

### 문제 특징 키워드
###`정렬` `최솟값` `리스트 거꾸로 생각`
