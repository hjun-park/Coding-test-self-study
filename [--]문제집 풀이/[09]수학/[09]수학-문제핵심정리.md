# 수학 문제 핵심 정리

## 에라토스테네스의 체

에라토스테네스의 체 알고리즘

1) 2부터 N까지 모든 정수를 적는다.
2) 아직 지우지 않은 수 중 가장 작은 수를 찾는다. 이것을 P라고 하고, 이 수는 소수이다.
3) P를 지우고, 아직 지우지 않은 P의 배수를 크기 순서대로 지운다.
4) 아직 모든 수를 지우지 않았다면, 다시 2번 단계로 간다.

```python
# 에라토스테네스의 체
def find_prime_number(M, N):
    array = [True] * (N + 1)

    for i in range(2, len(array) // 2 + 1):
        if array[i]:
            for j in range(i * 2, len(array), i):
                array[j] = False

    return [x for x in range(2, N + 1) if array[x]]
```

<br />

## GCD, LCM

- GCD 구한 후 LCM을 구한다.

```python
# 70. 더 짧은 GCD 구하기
# 나머지가 0일 때까지 계속해서 제수를 줄여나간다., 그리고 그걸 리턴
def gcd2(x, y):
    while y:  # y가 다 할 때까지
        x, y = y, x % y  # 변환, 나머지
    return x  # x를 반환


# 71. 유클리드 호제법 LCM
# 곱 & GCD
def lcm(x, y):
    return (x * y) // gcd(x, y)  # 곱, gcd
```

<br />

## [연습-S3]9613-GCD 합

- 가능한 모든 쌍의 GCD 연산 합을 구하는 파트 (for문 동작 확인)

```python
def GCD(x, y):
    while y:
        x, y = y, x % y
    return x


for _ in range(int(input().rstrip())):
    result = 0
    numbers = list(map(int, input().split()))
    N = numbers.pop(0)

    # 가능한 모든 쌍의 GCD 연산 합을 구함
    for i in range(N):
        for j in range(i + 1, N):
            gcd_num = GCD(numbers[i], numbers[j])
            result += gcd_num

    print(result)
```

<br />

## 순서 X 중복제거, 순서 O 중복제거

```python
from collections import defaultdict

arr = [1, 1, 1, 0, 0]

arr = list(set(arr))  # [0, 1]
arr = list(defaultdict.fromkeys(arr))  # [1, 0]
```

<br />

## 진법변환코드(10진-N진)

```python
import string

tmp = string.digits + string.ascii_lowercase


def convert(num, base):
    q, r = divmod(num, base)
    if q == 0:
        return tmp[r]
    else:
        return convert(q, base) + tmp[r]
```

<br />

## 약수 구하기

```python
num = 18
x = {x for x in range(1, num) if num % x == 0}


# 시간복잡도를 줄인 약수 개수

def getMyDivisor(n):
    divisorsList = []

    for i in range(1, int(n ** (1 / 2)) + 1):
        if n % i == 0:
            divisorsList.append(i)
            # 약수 i와 이를 나누는 n // i
            # 5 * 5 = 25 같은 경우도 있으므로 중복된 경우가 아닌 경우만 넣어줌
            if i != (n//i):   
                divisorsList.append(n // i)

    divisorsList.sort()

    return divisorsList
```

<br />

## 좌표 계산하기
```python
# 좌표 거리 계산해주기
for a, b, c in zip(L_pos, R_pos, now):
    L_dist += abs(a - c)
    R_dist += abs(b - c)

# now와 L, R 사이의 거리를 구하는 계산식
```
