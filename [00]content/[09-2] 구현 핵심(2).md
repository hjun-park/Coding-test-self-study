# 코딩테스트 구현 핵심 정리

- - -

**기입할 점**
1) 어떻게 어떤 생각으로 문제를 접근하여 어떤 아이디어를 냈는가 ?
2) 특별히 어느 부분이 구현이 힘들었고 그건 어떻게 구현을 하였는가 ? 
3) 나는 어떤 부분이 어려웠고 무엇을 배웠는가 ?

- - -

## [Lv3] 외벽 점검

- [permutation 풀이](htps://dreamtreeits.tistory.com/44?category=1225887)
- [set으로 풀이](https://kjy042386.tistory.com/42)

### 내 생각
```markdown
우선, 제한사항에서 볼 때 완전탐색 문제라는 것을 알았다.
그러나 고려할 사항이 정말 많았고 결국 해결하지는 못했다. (원을 리스트로 생각했으나 그 이후 연산이 어려웠다.)
완전탐색 문제에서는 permutation을 사용하면 좀 더 수월해질 것이다.
```


### 순서
1) 원형인 경우 길이를 2배로 해서 일자로 구성한다, len(weak)을 2배 늘리면 된다.
2) 투입할 친구의 최솟값을 찾기 위해 dist 최대 길이보다 +1 더 큰 값으로 초기화한다. (answer = len(dist) + 1)
3) 취약한 부분을 순회 하면서 그 안에는 순열로 친구 여려명 투입해서 점검한다.
4) 그렇게 해서 answer를 반환하되, answer가 친구 수보다 많으면 -1 반환

### 배운 점
1) 배열 길이가 크지 않고, 모든 경우의 수를 따져보아야 하는 경우 permutation을 통해 확인하면 쉽게 알 수 있다.



```python
import sys
from itertools import permutations

input = sys.stdin.readline



def solution(n, weak, dist):
    length = len(weak)

    # 1) weak 배열을 2배 길게 늘린다. 그렇게 되면 방향을 고려할 필요가 없게 된다.
    # 즉, 12m 원형 외벽에서 4m부터 9m까지 반시계방향으로 도는 것 == 9m부터 12+4m = 16m 시계 방향과 같다.
    for i in range(length):
        weak.append(weak[i] + n)  # n을 더하는 이유는 weak는 외벽 위치가 적혀있고, 상대값이기 때문이다.

    # 2) 투입할 친구의 최솟값,친구 수 + 1 로 초기화
    min_friend = len(dist) + 1

    # 3) 외벽 취약점을 하나하나 start를 이동하면서 찾는다.
    # 아래 코드 순서
    #  - 취약한 부분 개수만큼 순회 (첫번째 케이스는 4개 )
    #  - 친구 전체에 대해 모든 순열을 만들고 처음 친구의 취약점 점검 가능한 범위 설정
    #  - 만약에 그 친구가 모든 취약점을 확인 가능하다면 (if not position < weak[i]) 최솟값을 1로 업데이트 할 것이다.
    #  - 만약에 그 친구가 모든 취약점 탐색이 불가능하다면 다음 친구를 투입하여
    for start in range(length):
        for friends in list(permutations(dist, len(dist))):
            friend_count = 1  # 투입할 친구 수

            # 현재 친구가 확인할 수 있는 최대 거리
            # position에는 취약점 시작지 + 해당 친구가 볼 수 있는 거리
            position = weak[start] + friends[friend_count - 1]

            # 시작점부터 모든 취약지점까지 확인
            for i in range(start, start + length):
                if position < weak[i]:  # 확인할 수 있는 최대 거리를 넘었다면
                    friend_count += 1  # 다음 친구 투입

                    # 더 이상 투입할 친구가 없다면 다음 친구로 탐색하기 위해 빠져나온다.
                    if friend_count > len(dist):
                        break

                    # 친구가 확인할 수 있는 최대 거리를 업데이트 한다.
                    # 만약 처음 친구는 position이 weak[i]보다 작았지만
                    # 어떤 친구가 모든 weak[i]값을 커버 가능한다면
                    # if position < weak[i] 내 코드를 순환하지 않으므로 최솟값이 나오게 된다.
                    # https://kom-story.tistory.com/191
                    position = weak[i] + friends[friend_count - 1]

            # 투입할 친구의 최솟값을 업데이트
            min_friend = min(min_friend, friend_count)

    if min_friend > len(dist):
        return -1
    return min_friend
```

<br >

- - -

## [Lv3] 블록 이동하기

 
