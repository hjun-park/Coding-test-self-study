# 코딩테스트 구현 핵심 정리

- - -

**기입할 점**
1) 어떻게 어떤 생각으로 문제를 접근하여 어떤 아이디어를 냈는가 ?
2) 특별히 어느 부분이 구현이 힘들었고 그건 어떻게 구현을 하였는가 ? 
3) 나는 어떤 부분이 어려웠고 무엇을 배웠는가 ?

- - -

## [Lv3] 외벽 점검

- [permutation 풀이](htps://dreamtreeits.tistory.com/44?category=1225887)
- [set으로 풀이](https://kjy042386.tistory.com/42)

### 내 생각
```markdown
우선, 제한사항에서 볼 때 완전탐색 문제라는 것을 알았다.
그러나 고려할 사항이 정말 많았고 결국 해결하지는 못했다. (원을 리스트로 생각했으나 그 이후 연산이 어려웠다.)
완전탐색 문제에서는 permutation을 사용하면 좀 더 수월해질 것이다.
```


### 순서
1) 원형인 경우 길이를 2배로 해서 일자로 구성한다, len(weak)을 2배 늘리면 된다.
2) 투입할 친구의 최솟값을 찾기 위해 dist 최대 길이보다 +1 더 큰 값으로 초기화한다. (answer = len(dist) + 1)
3) 취약한 부분을 순회 하면서 그 안에는 순열로 친구 여려명 투입해서 점검한다.
4) 그렇게 해서 answer를 반환하되, answer가 친구 수보다 많으면 -1 반환

### 배운 점
1) 배열 길이가 크지 않고, 모든 경우의 수를 따져보아야 하는 경우 permutation을 통해 확인하면 쉽게 알 수 있다.



```python
import sys
from itertools import permutations

input = sys.stdin.readline



def solution(n, weak, dist):
    length = len(weak)

    # 1) weak 배열을 2배 길게 늘린다. 그렇게 되면 방향을 고려할 필요가 없게 된다.
    # 즉, 12m 원형 외벽에서 4m부터 9m까지 반시계방향으로 도는 것 == 9m부터 12+4m = 16m 시계 방향과 같다.
    for i in range(length):
        weak.append(weak[i] + n)  # n을 더하는 이유는 weak는 외벽 위치가 적혀있고, 상대값이기 때문이다.

    # 2) 투입할 친구의 최솟값,친구 수 + 1 로 초기화
    min_friend = len(dist) + 1

    # 3) 외벽 취약점을 하나하나 start를 이동하면서 찾는다.
    # 아래 코드 순서
    #  - 취약한 부분 개수만큼 순회 (첫번째 케이스는 4개 )
    #  - 친구 전체에 대해 모든 순열을 만들고 처음 친구의 취약점 점검 가능한 범위 설정
    #  - 만약에 그 친구가 모든 취약점을 확인 가능하다면 (if not position < weak[i]) 최솟값을 1로 업데이트 할 것이다.
    #  - 만약에 그 친구가 모든 취약점 탐색이 불가능하다면 다음 친구를 투입하여
    for start in range(length):
        for friends in list(permutations(dist, len(dist))):
            friend_count = 1  # 투입할 친구 수

            # 현재 친구가 확인할 수 있는 최대 거리
            # position에는 취약점 시작지 + 해당 친구가 볼 수 있는 거리
            position = weak[start] + friends[friend_count - 1]

            # 시작점부터 모든 취약지점까지 확인
            for i in range(start, start + length):
                if position < weak[i]:  # 확인할 수 있는 최대 거리를 넘었다면
                    friend_count += 1  # 다음 친구 투입

                    # 더 이상 투입할 친구가 없다면 다음 친구로 탐색하기 위해 빠져나온다.
                    if friend_count > len(dist):
                        break

                    # 친구가 확인할 수 있는 최대 거리를 업데이트 한다.
                    # 만약 처음 친구는 position이 weak[i]보다 작았지만
                    # 어떤 친구가 모든 weak[i]값을 커버 가능한다면
                    # if position < weak[i] 내 코드를 순환하지 않으므로 최솟값이 나오게 된다.
                    # https://kom-story.tistory.com/191
                    position = weak[i] + friends[friend_count - 1]

            # 투입할 친구의 최솟값을 업데이트
            min_friend = min(min_friend, friend_count)

    if min_friend > len(dist):
        return -1
    return min_friend
```

<br >

- - -

## [G5]4179-불!

1) 어떻게 어떤 생각으로 문제를 접근하여 어떤 아이디어를 냈는가 
- 처음에는 지훈이가 이동 후 불이 이동하니, deepcopy 처리하려고 했다.
- 그리고 지훈이가 이동하는 부분은 bfs로 처리하고 불은 완전탐색으로 하려고했다.  

2) 특별히 어느 부분이 구현이 힘들었고 그건 어떻게 구현을 하였는가 ?
- 그중에서도 불을 이동하고 지훈이가 이동할 때 시간체크를 하는 것이 문제였다. 
- 굳이 deepcopy를 쓸 필요가 없었다. 
 
3) 나는 어떤 부분이 어려웠고 무엇을 배웠는가 ?
- deepcopy 대신에 지훈이도 deque 만들어 bfs 순환, 불도 deque 만들어 bfs 순환해주면 되었다.
- visited에 시간을 체크하는 방법 뿐만 아니라 문자가 들어 있는 graph에도 시간을 체크하는 방법이 있다.
- 자세한 것은 아래 코드를 참고한다.


```python

import sys
from collections import deque

input = sys.stdin.readline

dx = [0, -1, 0, 1]
dy = [-1, 0, 1, 0]

R, C = map(int, input().split())
graph = []

# 불의 방문처리 ( 1이 방문된 상태 )
visited = [[0] * C for _ in range(R)]
f = deque()
q = deque()

''' 
 1) 좌표 표시
  - 처음 지훈 위치 : J
  - 불의 위치 : F
  - 지훈이가 이동할 때 위치 : 정수값 (몇 분)
  - 벽 : #
  - 이동가능 : .
  
  2) visited를 2개 만들어서 불과 지훈이의 이동경로를 처리하기에는 메모리가 부족하다.
     따라서 불의 이동 경로만 visited를 만들어주고 
     시간체크만 해도 되는 지훈이는, 지훈이 이동 경로에는 몇 분이 걸렸나 graph에 체크한다.
'''


def bfs():
    # 2) 지훈이와 불이 이동하는 두 deque
    global q, f

    # 2) 무한루프
    while True:
        # 2-1) 지훈이가 이동할 수 있는 곳은 따로 담아둔다.
        #      그 이유는 지훈이의 이동 + 불의 이동이 1초라서 그렇다.
        temp = deque()
        while q:
            x, y = q.popleft()

            # 2-2) q에서 꺼낸 위치가 미로의 가장자리면서 현재 위치에 불이 없다면 탈출 가능
            if (x == R - 1 or y == C - 1 or x == 0 or y == 0) and graph[x][y] != 'F':
                return graph[x][y] + 1  # 지훈 위치 (시간) 반환

            for d in range(4):
                nx = x + dx[d]
                ny = y + dy[d]

                # 2-3) 범위 내에서 다음 이동할 위치가 '.' 이면서 현재 위치에 불이 없다면 시간체크 & 이동
                if 0 <= nx < R and 0 <= ny < C:
                    if graph[nx][ny] == '.' and graph[x][y] != 'F':
                        graph[nx][ny] = graph[x][y] + 1
                        temp.append((nx, ny))

        # 3) 지훈이가 1초동안 이동 가능한 곳은 temp이고 이동이 끝났으므로 q에 다시 담아둔다.
        q = temp

        # 4) 큐가 비어 있으면 불 혹은 장애물로 둘러싸인 상태이므로 이동 불가
        if not q:
            return "IMPOSSIBLE"

        # 5) 다음으로 지훈이가 아닌 불이 1초동안 이동할 수 있는 곳을 파악하기 위해 temp를 초기화한다.
        temp = deque()
        while f:
            x, y = f.popleft()

            for d in range(4):
                nx = x + dx[d]
                ny = y + dy[d]

                # 6) 이동하려는 곳이 이동 범위 이내이며, 벽이 아니면서 방문하지 않았다면
                #    temp에 위치를 담아두고 방문처리 후 해당 위치를 불태운다.
                if 0 <= nx < R and 0 <= ny < C:
                    if not visited[nx][ny] and graph[nx][ny] != "#":
                        temp.append([nx, ny])
                        visited[nx][ny] = True
                        graph[nx][ny] = "F"

        # 7) 불이 1초동안 이동 가능한 곳은 temp이고 이동이 끝났으므로 다시 f 담아둔다.
        f = temp


# 1) 가장 먼저 지훈 위치와 불의 위치를 deque에 담아준다.
#    graph에는 장애물과 불 위치가 문자로 주어져 있지만
#    지훈이가 있는 곳 (J)는 시간을 세기 위해 정수 0으로 초기화한다.
#    앞으로 지훈이가 이동하는 경로는 몇 분에 위치해 있는지 시간 값으로 덮어 쓸 것이다.
#    visited를 이용해서 시간초를 체크하면 좋겠지만,
#    이렇게하는 이유는 문제에서 주어진 메모리가 한정되어 있기 때문이다.
def find():
    for i in range(R):
        a = list(input().rstrip())
        graph.append(a)
        for j in range(C):
            if a[j] == 'J':
                q.append((i, j))
                graph[i][j] = 0  # 다른데는 문자이지만 지훈이의 위치로 시간을 셀 예정
            elif a[j] == 'F':
                f.append((i, j))
                visited[i][j] = True


find()
print(bfs())


```

<br >

- - -

## [G5]4179-불!

**기입할 점**
1) 어떻게 어떤 생각으로 문제를 접근하여 어떤 아이디어를 냈는가 ?
2) 특별히 어느 부분이 구현이 힘들었고 그건 어떻게 구현을 하였는가 ? 
3) 나는 어떤 부분이 어려웠고 무엇을 배웠는가 ?

 

