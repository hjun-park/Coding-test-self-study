# 코딩테스트 구현 핵심 정리
- - -
### 목차
[001.투포인터](#투포인터)

[002.백트래킹](#백트래킹)
- - -

## [G3]17822-원판돌리기
> 팁1 : 숫자의 자릿수가 다른 경우는 뒤에서부터 확인한다.

<br >

#### 0) 방향은 사전으로 정의한다.
```python
change_dir = {0: 1, 1: -1}
```


#### 1) 리스트를 rotate하고 싶을 때
```python
q = deque()
q.append([1, 2, 3, 4])
q[0].rotate(change_dir[d] * k)    # d의 방향대로 k만큼 rotate
```

#### 2) N까지의 숫자 중에서 x와 배수인 것을 확인하는 방법
```python
# 1. 0부터 N까지 순회하면서 x와 나누어 떨어지는지 확인한다.
for i in range(1, N+1):
    if i % x == 0:
        print(f'x의 배수 {i}')
```

#### 3) 이차원 배열에서 0을 세는 방법
```python
graph = [[1, 0], [3, 4]]
zero_cnt = sum([graph[i].count(0)] for i in range(N))
```

#### 4) q의 전체합을 구하는 방법
```python
q = ([1, 2, 3, 4])
dividend = sum(sum(q, deque()))
```

<br >

- - -


## [S3]1966-프린터 큐 

<br >

#### 0) 특정 인덱스 값이 몇 번째로 pop이 되는지 체크하는 방법으로써는 visited를 이용하면됨
```python
M = 1   # 특정 인덱스 값

q = list(map(int, input().split())) # 프린트 큐 중요도 값
visited = [False] * len(q)
q[M] = True
```

<br >

- - -

## [S4]1244-스위치 켜고 끄기 
#### 투포인터1
<br >

#### 0) 투포인터를 이용하여 바꿔줄 자릿수를 찾음
```python
def female_student(num):
    left = num - 2
    right = num

    # 처음 한 자리는 직접 바꿔줌
    if switch[(num - 1)] == 0:
        switch[(num - 1)] = 1
    else:
        switch[(num - 1)] = 0

    # 그 다음 대칭부터는 같을 경우에만 바꿔줌
    while 0 <= left and right < N and switch[left] == switch[right]:
        if switch[left] == 0:
            switch[left], switch[right] = 1, 1
        elif switch[left] == 1:
            switch[left], switch[right] = 0, 0

        left -= 1
        right += 1
```

<br >

- - -

##[Lv3]N-Queens
#### 백트래킹1

<br >

#### 0) 백트래킹을 겪어볼 수 있는 대표적인 문제

```python
def dfs(n):
    global res  # N-Queen 놓는 결과 수
    if n == N:  # n이 N끝까지 간다는 경우는 퀸을 다 놓았다는 경우
        res += 1
    else:
        for i in range(N):
            row[n] = i  # n번째 행의 i번째 열에 퀸이 있다고 가정
            if check(n):
                dfs(n + 1)
```

#### 1) 대각선의 경우   ↗, ↙  해당 대각선 방향 각각의 인덱스의 합들과 같다는 규칙이 있었습니다.
#### (체스판에 직접 인덱스를 매겨서 더해보시면 이해가 쉽습니다. ex) (0,2) = (1,1) = (2,0) )

```python
row[n] = i  # n번째 행의 i번째 열에 퀸이 있다고 가정
def check(n):   
    for i in range(n):
        # 열의 경우 
        # row[n] = m의 의미 -> n번째 행의 m번째 열 (n, m)
        # row[n] == row[i]는 서로 다른 행에 같은 열로 놓인 경우
        # or
        # 대각선의 경우
        # 열은 열끼리 빼고 행은 행끼리 뺐을 때 서로 같은 값이 되어야 같은 대각선상에 놓였다고 할 수 있다.
        # (0,2) == (1,1) == (2,0) , (0,2) == (2,0)
        # abs() -> 열끼리 뺀 경우,  n-i => 행 끼리 뺀 경우
        if row[n] == row[i] or abs(row[n] - row[i]) == n - i:   # n퀸한테 걸리는 경우
            return 0
    return 1
```

```markdown
https://hellominchan.tistory.com/176
1. N 개의 퀸을 놓아야 하기 때문에 각 행마다 1개씩 존재해야 한다. (좌우로 움직이니까)
1-1. 행마다 한 개씩 놓는다면 가로(좌우)는 확인할 필요가 없다.
2. 그럼 결국 세로와 대각선만을 확인하면 되는데, 세로의 경우 1차원 배열로 확인 가능
2-1. 대각선의 경우   ↗, ↙  해당 대각선 방향 각각의 인덱스의 합들과 같다는 규칙이 있었습니다.
    (체스판에 직접 인덱스를 매겨서 더해보시면 이해가 쉽습니다. ex) (0,2) = (1,1) = (2,0) )
```

<br >

- - -

##[G4]2638-치즈
 - 공기와 2면 이상 닿은 치즈가 녹는다 했을 때 다 녹기까지의 시간을 체크하는 문제

<br >

#### 0) 치즈 순회하면서 3 이상인 부분을 녹일 때 꼭 BFS로 순회하려고 하지 않아도 된다.
#### 0-1) 기존 생각은 BFS로 돌면서 visited로 방문체크하려고 했는데 visited가 2개 만들어지기 때문에
#### 0-2) 어떻게 처리할 지 곤란했었다, 하지만 그냥 체크하는경우 bool값 만들고 for문으로 순회해도 간단히 가능하다.

```python
# 치즈를 순회하면서 3 이상인 부분은 녹인다. ( 처음값이 1이고 공기 2번 접하면 3이 됨)
def cheese():
    is_melted = False

    for x in range(N):
        for y in range(M):
            if graph[x][y] >= 3:
                graph[x][y] = 0
                is_melted = True
            elif graph[x][y] == 2:  # 2인 부분은 녹일 수 없으므로 다시 1로 초기화
                graph[x][y] = 1

    return is_melted
```

<br >

- - -

##[Lv3]하노이의 탑
 - 하노이의 탑은 https://stricky.tistory.com/155 참고
 - 재귀는 반드시 순환부, 종료부로 구성된다는 점

<br >

```python
def hanoi(n, at, to, aux):
    if n == 1:
        answer.append([at, to])
        return

    # 원반 n-1개를 보조기둥(2번)으로 이동
    hanoi(n - 1, at, aux, to)

    # 가장 큰 원반은 3번 기둥 (목적지)로 이동
    answer.append([at, to])

    # 나머지 보조기둥(2번) -> 목적지(3번) 이동
    hanoi(n - 1, aux, to, at)


def solution(n):
    hanoi(n, 1, 3, 2)
```

<br >

- - -

##[G4]내리막 길
 - DFS와 DP를 함께 사용한 예제
 - DP 길찾기의 경우 뒤에서부터 찾는 방법도 접근방법 중 하나
 - DP값이 -1이면 미방문, 0이면 방문했지만 방법이 없음, N이면 N개의 길이 있음을 의미
 - [https://seoyoung2.github.io/algorithm/2020/06/25/Baekjoon-1520.html]

<br >

```python
# 1)
dp = [[-1] * N for _ in range(M)]

def dfs(x, y):
    # 2-1)
    if x == 0 and y == 0:
        return 1

    if dp[x][y] == -1:
        dp[x][y] = 0
        for d in range(4):
            nx = x + dx[d]
            ny = y + dy[d]

            if 0 <= nx < M and 0 <= ny < N:
                if graph[x][y] < graph[nx][ny]:
                    dp[x][y] += dfs(nx, ny)
    return dp[x][y]


print(dfs(M - 1, N - 1))

```

<br >

- - -

##[G5]주사위 쌓기
 - 딕셔너리를 이용해서 주사위의 마주보는 값을 정의해 줌
 - 생각보다 난이도 있어서 직접 문제를 보는 것이 더 나을 수 있다. 

### [브루트포싱 문제](https://velog.io/@yoonkeem/BOJ-2116%EB%B2%88-%EC%A3%BC%EC%82%AC%EC%9C%84-%EC%8C%93%EA%B8%B0-%ED%8C%8C%EC%9D%B4%EC%8D%AC)

<br >

- - -

##[G5]2174-로봇 시뮬레이션
 - 100% 구현문제, 참고한 전체 코드 전부 참고하기 좋은방식
 - 방향 정하는게 굉장히 어려운 문제 [로봇 시뮬레이션](https://rebas.kr/739)
 - 회전 공식은 다음과 같다. 왼쪽 회전 : (인덱스+1)%4, 오른쪽 회전 : (인덱스+3)%4 
```python
1) 공식대로 적용하려면 왼쪽으로 회전해야한다. 방향은 [좌,하,우,상]-[서,남,동,북]  
    그렇게되면 directions = {'W': 0, 'S': 1, 'E': 2, 'N': 3} 완성
2) 다음으로 dx, dy를 정해야한다. (좌하우상) 문제를 자세히 보면 행 값은 반대로 되어 있다.
   따라서 dx = [0, -1, 0, 1] dy = [-1, 0, 1, 0] --> 좌표에서 좌,하,우,상으로 정한 것이다.
```
   
       

<br >


```python
A, B = map(int, input().split())
N, M = map(int, input().split())

# directions = {'S': 0, 'E': 1, 'N': 2, 'W': 3}
directions = {'W': 0, 'S': 1, 'E': 2, 'N': 3}

'''
    https://rebas.kr/739
'''

#       S  E  N  W
# dx = [-1, 0, 1, 0]
# dy = [0, 1, 0, -1]

# 좌하우상
#     W  S   E  N
dx = [0, -1, 0, 1]
dy = [-1, 0, 1, 0]

# dx, dy = (-1, 0, 1, 0), (0, 1, 0, -1)
w = [[0] * (A + 1) for _ in range(B + 1)]
r = [[0, 0, 0] for _ in range(N + 1)]


def solve(i, d, c):
    x, y, z = r[i]
    w[x][y] = 0
    for _ in range(c):
        if d == 'L':
            z = (z + 1) % 4
        elif d == 'R':
            z = (z + 3) % 4
        else:
            x, y = x + dx[z], y + dy[z]
            if x < 1 or x > B or y < 1 or y > A:
                print("Robot %d crashes into the wall" % i)
                return True
            if w[x][y]:
                print("Robot %d crashes into robot %d" % (i, w[x][y]))
                return True
    r[i] = x, y, z
    w[x][y] = i
    return False


for i in range(1, N + 1):
    x, y, z = input().split()
    w[int(y)][int(x)] = i
    r[i] = [int(y), int(x), directions[z]]

crash = False
for _ in range(M):
    i, d, c = input().split()
    if not crash:
        crash = solve(int(i), d, int(c))

if not crash:
    print("OK")


```

<br />

- - -

## [G5] 7490-0만들기

- 백트래킹의 기본 개념 문제 - [백트래킹 기본개념](https://blog.encrypted.gg/732)
- 문자열을 수학식으로 해결할 수 있는 `eval()` 함수
- 재귀형태의 DFS 백트래킹 코드는 다음과 같다.

```python
def dfs(now, formula):
    # 개수가 N과 같으면 연산하기
    if now == N + 1:
        calc(formula)
        return

    # 다르면 계산식 추가
    dfs(now + 1, formula + ' ' + str(now))
    dfs(now + 1, formula + '+' + str(now))
    dfs(now + 1, formula + '-' + str(now))
```

<br >


