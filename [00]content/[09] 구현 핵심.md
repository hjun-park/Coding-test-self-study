# 코딩테스트 구현 핵심 정리
- - -
### 목차
[001.투포인터](#투포인터)

[002.백트래킹](#백트래킹)
- - -

## [G3]17822-원판돌리기
> 팁1 : 숫자의 자릿수가 다른 경우는 뒤에서부터 확인한다.

<br >

#### 0) 방향은 사전으로 정의한다.
```python
change_dir = {0: 1, 1: -1}
```


#### 1) 리스트를 rotate하고 싶을 때
```python
q = deque()
q.append([1, 2, 3, 4])
q[0].rotate(change_dir[d] * k)    # d의 방향대로 k만큼 rotate
```

#### 2) N까지의 숫자 중에서 x와 배수인 것을 확인하는 방법
```python
# 1. 0부터 N까지 순회하면서 x와 나누어 떨어지는지 확인한다.
for i in range(1, N+1):
    if i % x == 0:
        print(f'x의 배수 {i}')
```

#### 3) 이차원 배열에서 0을 세는 방법
```python
graph = [[1, 0], [3, 4]]
zero_cnt = sum([graph[i].count(0)] for i in range(N))
```

#### 4) q의 전체합을 구하는 방법
```python
q = ([1, 2, 3, 4])
dividend = sum(sum(q, deque()))
```

<br >

- - -


## [S3]1966-프린터 큐 

<br >

#### 0) 특정 인덱스 값이 몇 번째로 pop이 되는지 체크하는 방법으로써는 visited를 이용하면됨
```python
M = 1   # 특정 인덱스 값

q = list(map(int, input().split())) # 프린트 큐 중요도 값
visited = [False] * len(q)
q[M] = True
```

<br >

- - -

## [S4]1244-스위치 켜고 끄기 
#### 투포인터1
<br >

#### 0) 투포인터를 이용하여 바꿔줄 자릿수를 찾음
```python
def female_student(num):
    left = num - 2
    right = num

    # 처음 한 자리는 직접 바꿔줌
    if switch[(num - 1)] == 0:
        switch[(num - 1)] = 1
    else:
        switch[(num - 1)] = 0

    # 그 다음 대칭부터는 같을 경우에만 바꿔줌
    while 0 <= left and right < N and switch[left] == switch[right]:
        if switch[left] == 0:
            switch[left], switch[right] = 1, 1
        elif switch[left] == 1:
            switch[left], switch[right] = 0, 0

        left -= 1
        right += 1
```

<br >

- - -

##[Lv3]N-Queens
#### 백트래킹1

<br >

#### 0) 백트래킹을 겪어볼 수 있는 대표적인 문제

```python
def dfs(n):
    global res  # N-Queen 놓는 결과 수
    if n == N:  # n이 N끝까지 간다는 경우는 퀸을 다 놓았다는 경우
        res += 1
    else:
        for i in range(N):
            row[n] = i  # n번째 행의 i번째 열에 퀸이 있다고 가정
            if check(n):
                dfs(n + 1)
```

#### 1) 대각선의 경우   ↗, ↙  해당 대각선 방향 각각의 인덱스의 합들과 같다는 규칙이 있었습니다.
#### (체스판에 직접 인덱스를 매겨서 더해보시면 이해가 쉽습니다. ex) (0,2) = (1,1) = (2,0) )

```python
row[n] = i  # n번째 행의 i번째 열에 퀸이 있다고 가정
def check(n):   
    for i in range(n):
        # 열의 경우 
        # row[n] = m의 의미 -> n번째 행의 m번째 열 (n, m)
        # row[n] == row[i]는 서로 다른 행에 같은 열로 놓인 경우
        # or
        # 대각선의 경우
        # 열은 열끼리 빼고 행은 행끼리 뺐을 때 서로 같은 값이 되어야 같은 대각선상에 놓였다고 할 수 있다.
        # (0,2) == (1,1) == (2,0) , (0,2) == (2,0)
        # abs() -> 열끼리 뺀 경우,  n-i => 행 끼리 뺀 경우
        if row[n] == row[i] or abs(row[n] - row[i]) == n - i:   # n퀸한테 걸리는 경우
            return 0
    return 1
```

```markdown
https://hellominchan.tistory.com/176
1. N 개의 퀸을 놓아야 하기 때문에 각 행마다 1개씩 존재해야 한다. (좌우로 움직이니까)
1-1. 행마다 한 개씩 놓는다면 가로(좌우)는 확인할 필요가 없다.
2. 그럼 결국 세로와 대각선만을 확인하면 되는데, 세로의 경우 1차원 배열로 확인 가능
2-1. 대각선의 경우   ↗, ↙  해당 대각선 방향 각각의 인덱스의 합들과 같다는 규칙이 있었습니다.
    (체스판에 직접 인덱스를 매겨서 더해보시면 이해가 쉽습니다. ex) (0,2) = (1,1) = (2,0) )
```

<br >

- - -

##[G4]2638-치즈
 - 공기와 2면 이상 닿은 치즈가 녹는다 했을 때 다 녹기까지의 시간을 체크하는 문제

<br >

#### 0) 치즈 순회하면서 3 이상인 부분을 녹일 때 꼭 BFS로 순회하려고 하지 않아도 된다.
#### 0-1) 기존 생각은 BFS로 돌면서 visited로 방문체크하려고 했는데 visited가 2개 만들어지기 때문에
#### 0-2) 어떻게 처리할 지 곤란했었다, 하지만 그냥 체크하는경우 bool값 만들고 for문으로 순회해도 간단히 가능하다.

```python
# 치즈를 순회하면서 3 이상인 부분은 녹인다. ( 처음값이 1이고 공기 2번 접하면 3이 됨)
def cheese():
    is_melted = False

    for x in range(N):
        for y in range(M):
            if graph[x][y] >= 3:
                graph[x][y] = 0
                is_melted = True
            elif graph[x][y] == 2:  # 2인 부분은 녹일 수 없으므로 다시 1로 초기화
                graph[x][y] = 1

    return is_melted
```

<br >

- - -

##[Lv3]하노이의 탑
 - 하노이의 탑은 https://stricky.tistory.com/155 참고
 - 재귀는 반드시 순환부, 종료부로 구성된다는 점

<br >

```python
def hanoi(n, at, to, aux):
    if n == 1:
        answer.append([at, to])
        return

    # 원반 n-1개를 보조기둥(2번)으로 이동
    hanoi(n - 1, at, aux, to)

    # 가장 큰 원반은 3번 기둥 (목적지)로 이동
    answer.append([at, to])

    # 나머지 보조기둥(2번) -> 목적지(3번) 이동
    hanoi(n - 1, aux, to, at)


def solution(n):
    hanoi(n, 1, 3, 2)
```

<br >

- - -

##[G4]내리막 길
 - DFS와 DP를 함께 사용한 예제
 - DP 길찾기의 경우 뒤에서부터 찾는 방법도 접근방법 중 하나
 - DP값이 -1이면 미방문, 0이면 방문했지만 방법이 없음, N이면 N개의 길이 있음을 의미
 - [https://seoyoung2.github.io/algorithm/2020/06/25/Baekjoon-1520.html]

<br >

```python
# 1)
dp = [[-1] * N for _ in range(M)]

def dfs(x, y):
    # 2-1)
    if x == 0 and y == 0:
        return 1

    if dp[x][y] == -1:
        dp[x][y] = 0
        for d in range(4):
            nx = x + dx[d]
            ny = y + dy[d]

            if 0 <= nx < M and 0 <= ny < N:
                if graph[x][y] < graph[nx][ny]:
                    dp[x][y] += dfs(nx, ny)
    return dp[x][y]


print(dfs(M - 1, N - 1))

```

<br >

- - -

##[G5]주사위 쌓기
 - 딕셔너리를 이용해서 주사위의 마주보는 값을 정의해 줌
 - 생각보다 난이도 있어서 직접 문제를 보는 것이 더 나을 수 있다. 

### [브루트포싱 문제](https://velog.io/@yoonkeem/BOJ-2116%EB%B2%88-%EC%A3%BC%EC%82%AC%EC%9C%84-%EC%8C%93%EA%B8%B0-%ED%8C%8C%EC%9D%B4%EC%8D%AC)

<br >

- - -

##[G5]2174-로봇 시뮬레이션
 - 100% 구현문제, 참고한 전체 코드 전부 참고하기 좋은방식
 - 방향 정하는게 굉장히 어려운 문제 [로봇 시뮬레이션](https://rebas.kr/739)
 - 회전 공식은 다음과 같다. 왼쪽 회전 : (인덱스+1)%4, 오른쪽 회전 : (인덱스+3)%4 
```python
1) 공식대로 적용하려면 왼쪽으로 회전해야한다. 방향은 [좌,하,우,상]-[서,남,동,북]  
    그렇게되면 directions = {'W': 0, 'S': 1, 'E': 2, 'N': 3} 완성
2) 다음으로 dx, dy를 정해야한다. (좌하우상) 문제를 자세히 보면 행 값은 반대로 되어 있다.
   따라서 dx = [0, -1, 0, 1] dy = [-1, 0, 1, 0] --> 좌표에서 좌,하,우,상으로 정한 것이다.
```
   
       

<br >


```python
A, B = map(int, input().split())
N, M = map(int, input().split())

# directions = {'S': 0, 'E': 1, 'N': 2, 'W': 3}
directions = {'W': 0, 'S': 1, 'E': 2, 'N': 3}

'''
    https://rebas.kr/739
'''

#       S  E  N  W
# dx = [-1, 0, 1, 0]
# dy = [0, 1, 0, -1]

# 좌하우상
#     W  S   E  N
dx = [0, -1, 0, 1]
dy = [-1, 0, 1, 0]

# dx, dy = (-1, 0, 1, 0), (0, 1, 0, -1)
w = [[0] * (A + 1) for _ in range(B + 1)]
r = [[0, 0, 0] for _ in range(N + 1)]


def solve(i, d, c):
    x, y, z = r[i]
    w[x][y] = 0
    for _ in range(c):
        if d == 'L':
            z = (z + 1) % 4
        elif d == 'R':
            z = (z + 3) % 4
        else:
            x, y = x + dx[z], y + dy[z]
            if x < 1 or x > B or y < 1 or y > A:
                print("Robot %d crashes into the wall" % i)
                return True
            if w[x][y]:
                print("Robot %d crashes into robot %d" % (i, w[x][y]))
                return True
    r[i] = x, y, z
    w[x][y] = i
    return False


for i in range(1, N + 1):
    x, y, z = input().split()
    w[int(y)][int(x)] = i
    r[i] = [int(y), int(x), directions[z]]

crash = False
for _ in range(M):
    i, d, c = input().split()
    if not crash:
        crash = solve(int(i), d, int(c))

if not crash:
    print("OK")


```

<br />

- - -

## [G5] 7490-0만들기

- 백트래킹의 기본 개념 문제 - [백트래킹 기본개념](https://blog.encrypted.gg/732)
- 문자열을 수학식으로 해결할 수 있는 `eval()` 함수
- 재귀형태의 DFS 백트래킹 코드는 다음과 같다.

```python
def dfs(now, formula):
    # 개수가 N과 같으면 연산하기
    if now == N + 1:
        calc(formula)
        return

    # 다르면 계산식 추가
    dfs(now + 1, formula + ' ' + str(now))
    dfs(now + 1, formula + '+' + str(now))
    dfs(now + 1, formula + '-' + str(now))
```

<br >

- - -

## [G5] 1022-소용돌이 예쁘게 출력하기

- 너무 어려웠던 문제 [해설](https://hooongs.tistory.com/255)
- cnt, dcnt 값에 따라서 어떻게 출력이 달라지는지 확인 중요

```python
import sys

input = sys.stdin.readline

'''
    참고: https://hooongs.tistory.com/255
'''

# 반시계방향 선언
dx = [0, -1, 0, 1]
dy = [1, 0, -1, 0]

r1, c1, r2, c2 = map(int, input().split())

board = [[0] * (c2 - c1 + 1) for _ in range(r2 - r1 + 1)]  # 출력할 보드
number_of_board = (c2 - c1 + 1) * (r2 - r1 + 1)  # 출력할 보드 가로세로 사이즈

x = y = 0
num = 1
cnt = 0  # 한 방향에서 움직이는 횟수
dcnt = 1  # 한 방향에서 움직어야할 횟수 (cnt가 좌, 우를 가리키는 경우 1을 증가)
d = 0

while number_of_board > 0:  # 출력보드에 모든 값이 써질 때까지 시행
    if r1 <= x <= r2 and c1 <= y <= c2:  # 출력보드 사이즈 범위 안이라면
        number_of_board -= 1  # 출력보드에 쓸 것이므로 사이즈 -1
        board[x - r1][y - c1] = num  # 출력 보드에 num값을 대입
        max_num = num  # max_num을 num으로 설정 - 나중에 예쁘게 출력 위함(공백)

    # 이동 카운트와 num 증가
    num += 1
    cnt += 1

    # 방향 이동
    x = x + dx[d]
    y = y + dy[d]

    # 한 번 앞으로 이동하고 방향전환이 필요한지 여부 체크
    if cnt == dcnt:
        cnt = 0  # cnt를 0으로 초기화
        d = (d + 1) % 4  # 방향 전환
        if d == 0 or d == 2:  # 왼쪽 혹은 오른쪽 방향을 이동할 땐 이동횟수가 증가
            dcnt += 1

# 가장 큰 수에서 1을 빼줌 ( 소용돌이 끝을 고려 )
max_num_len = len(str(max_num - 1))
for i in range(r2 - r1 + 1):
    for j in range(c2 - c1 + 1):
        print(str(board[i][j]).rjust(max_num_len), end=' ')
    print()

```

<br >

- - -

## [G5] 15686-치킨 배달

- 치킨집 집계 시 2차원 배열을 아래와 같이 사용할 수도 있다.
- 특정 치킨집을 M개 고를 때에는 combinations 를 사용한다. 


```python
# 치킨과 집 집계
chicken = [[c, j] for c in range(N) for j in range(N) if graph[c][j] == 2]
home = [[i, j] for i in range(N) for j in range(N) if graph[i][j] == 1]

# 특정 치킨집을 M개 고르는 경우
chicken_select = list(combinations(chicken, M))
```

<br >

- - -

## [G4] 2239-스도쿠

- [좋은 해설](https://hooongs.tistory.com/255)    

<br >

### 1) 스도쿠에서는 가로, 세로, 3x3을 확인한다.

> 그중에서도 3x3 계산식인 `start_row = x // 3 * 3`를 잘 알아둔다.

```python

def valid(x, y, num):
    # 가로 탐색
    for col in range(9):
        if graph[x][col] == num:
            return False

    # 세로 탐색
    for row in range(9):
        if graph[row][y] == num:
            return False

    # 3x3 탐색
    start_row = x // 3 * 3
    start_col = y // 3 * 3
    for i in range(3):
        for j in range(3):
            if graph[start_row + i][start_col + j] == num:
                return False

    # 모든 탐색을 마치면 True
    return True
```

<br >

### 2) 백트래킹의 좋은 예제

> 백트래킹은 DFS 재귀를 이용한다. 종료조건이 있어야 하며, DFS 수행 후 조건을 체크하고나서 값을 복구해준다.

```python
# 백트래킹을 이용하여 계산해야 한다.
def dfs():
    # 1) 스도쿠에 빈 공간이 있는지 확인한다. 없으면 종료한다.
    r, c = find_empty()

    # DFS의 종료조건: r이 True라면
    if r is None:
        return True

    # 2) 빈 공간이 있다면 어떤 값이 들어갈 수 있는지 탐색 (가로, 세로, 3x3)
    #  - 찾으면 스도쿠에 집어넣는다.
    #  - 채워넣을 수 있는게 없다면 백트래킹
    else:
        for i in range(1, 10):
            if valid(r, c, i):  # 유효하면 값 집어넣기
                graph[r][c] = i
                if dfs():  # 추가한 값에 대해 다시 DFS를 수행한다.
                    return True
                graph[r][c] = 0  # 백트래킹
        return False

```
<br >

- - -

## [G5] 1013-Contact

- 정규표현식 문제
- re를 이용해서 해결, 처음에는 match를 이용하는 방법인 줄 알았다.
- 알고보니 전체를 매칭해야해서 fullmatch를 이용했다. 

```python
import re

'''
  # 파이썬 정규표현식 [https://wikidocs.net/4308]
  p = re.compile('ab*') # 컴파일하여 작업 수행하기 위한 객체 생성
  m = p.match("python") # 처음부터 정규식과 매칭되는지 확인
  s = p.search("python") # 문자열 전체를 검색하여 정규식과 매치되는지 검색
  이외에도 findall, findmatch가 있다.
  
  ** 핵심은 전체 매칭되는 것을 찾아야하므로 full match를 이용해야 한다.
  ( https://nerogarret.tistory.com/30 )
```

<br >

- - -

