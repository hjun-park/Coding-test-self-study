# 코딩테스트 그리디 핵심 정리
- - -
### 상세

- - -

## [S2]1931-회의실 배정
> 입력값으로 시작과 끝 시간이 여러개 주어진다면
> 시작 시간 순으로 정렬, 끝 시간 순으로 정렬한다.

<br >

#### 0) 첫, 끝 시간을 기준으로  2번 정렬 후 하나하나 체크  
```python
s = sorted(s, key=lambda a: (a[0], a[1]))

last = 0
cnt = 0

# 정렬된 s 순서쌍 배열에서 하나씩 빼고 ( X, Y )
# 당장 앞에 있는 이득만 챙겨보는 알고리즘
for i, j in s:
    if i >= last:   # 시작 시간 >= 이전에 끝나는 시간보다 크거나 같을 경우 (( 이 경우가 교체 가능한 시간 ))
        cnt += 1    # 카운트
        last = j    # 끝나는 시간을 Y로 지정
```

<br >

- - -

## [G1]1700-멀티탭 스케쥴링
> list index를 활용하는 문제

<br >

#### 0) index를 이용해서 어떤 플러그를 뽑을 지 찾는 예제  
```python
else:  # 플러그에 꽂을 공간이 없거나 같은 꽂힌게 없는 경우
    find_index = 0
    plugged_here = 0
    for j in range(N):  # 플러그 루프를 돈다.
        try:
            if find_index < numbers[i + 1:].index(plug[j]):  # 이후에 사용하는 플러그인지 확인한다.
                # 플러그에 꽂힌 번호 중에서 가전제품 맨 끝번호에 있는 것을 먼저 뽑는게 더 효율적이다.
                find_index = numbers[i + 1:].index(plug[j])
                plugged_here = j
        except ValueError:
            # 그렇지만 플러그에 꽂힌 번호(plug)가 가전제품 번호(numbers)에 없다면 그걸 가장 먼저 뽑는다.
            # 앞으로 사용할 일이 없기 때문이다.
            plugged_here = j
            break
```

<br >

- - -

## [G4]1715-카드 정렬하기
 - 카드팩을 특정 순서로 정렬해서 더했을 때 묶음이 최소가 되는 수를 찾기
> heapq를 사용하는 문제

<br >

#### 1) 최소 순으로 정렬할 때 꼭 정렬 쓸 필요 없이 heapq도 좋은 방법이다. 
```python
if len(hq) == 0:
    print(0)

result = 0
while len(hq) > 1:  # 한 번에 2개를 뽑을 것이기 때문에 길이가 2 이상
    pack1 = heapq.heappop(hq)
    pack2 = heapq.heappop(hq)

    result += (pack1 + pack2)
    heapq.heappush(hq, pack1 + pack2)

print(result)

```

<br >

- - -

## [G5]1041-주사위
 - 주사위를 유심히 살펴보고 공식을 내는 것이 중요 (어려움)
- [주사위 문제 해답](https://710jym.medium.com/baekjoon-1041-python-4153e686aec4)

<br >

- - -

## [Lv3]거스름돈
 - DP 문제였는데 엄청 어려웠음 다시 봐야함
 - [거스름돈 문제 해답](https://hwayomingdlog.tistory.com/100)
 - DP식은 `memo[price] += memo[price - coin]`
 - money = [1, 2, 5] 이고 n = 9일 때 `memo[9] = memo[9-5] + memo[9-6] + memo[9-7] + memo[9-8] +  memo[9-9]`
 - (for문 시작점은 동전값이고 n까지 1씩 증가해서 저렇게 다 더해준다. 9는 price이고 빼주는 값 5~9는 coin)

```python
import sys

input = sys.stdin.readline


# 각 동전별로 인해 늘어나는 경우의 수를 적기
# https://hwayomingdlog.tistory.com/100

def solution(n, money):
    # 메모이제이션
    # 각 인덱스에 해당하는 수를 만들 수 있는 가짓수를 기록
    memo = [0] * (n + 1)
    memo[0] = 1
    # 주어진 동전에 하나씩 접근
    for coin in money:
        for price in range(coin, n + 1):
            memo[price] += memo[price - coin]
    answer = memo[n] % 10000000007
    return answer
```

<br >

- - -


## [G5]2212-센서
- [문제 해설](https://journeytosth.tistory.com/16)
- 그리디에서는 정렬을 많이 사용하는 느낌
- 최소 1개의 센서와 통신할 수 있는 집중국들의 최소 걸이를 구하는 문제

<br >

- - -

## [LV3]숫자 게임

- 그리디 중에서 하나씩 정렬된 데이터를 뽑아서 사용하는 문제 ( heap을 이용 )
- heappify는 동작속도가 느리기 때문에 리스트에서 직접 넣어주었다.
- 여러 리스트에서 하나씩 뽑아서 쓰는 그리디 문제는 아래 유형이 대표 예제인 듯 싶었다.

```python
import heapq


def solution(A, B):
    hA, hB = [], []
    score = 0

    # 우선순위를 내림차순 정렬하기 위해서 (-1)곱하여 정렬
    # 이렇게 하면 A, B 모두 꺼낼 때 가장 큰 것먼저 나오게 된다.
    for a, b in zip(A, B):
        heapq.heappush(hA, -a)
        heapq.heappush(hB, -b)

    # 둘 중 하나가 끝날 때까지
    while hA and hB:
        popA = heapq.heappop(hA)
        popB = heapq.heappop(hB)

        # B가 더 큰 경우에만 처리
        if -popA < -popB:
            score += 1
        else:  # A가 더 크거나 비긴 경우 다음 비교를 위해 B는 push
            heapq.heappush(hB, popB)    # 이미 위에 (-1) 곱했기 때문에 그대로 집어넣어줘도 된다.

    return score


print(solution([5, 1, 3, 7], [2, 2, 6, 8]))
print(solution([2, 2, 2, 2], [1, 1, 1, 1]))

```

<br >

- - -

