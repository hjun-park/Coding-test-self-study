import sys

input = sys.stdin.readline

N = int(input().rstrip())

'''

    1) 단순히 계단 수만으로 f(N)을 구할 수 없다.
    2) 맨 마지막 수 d에 따라서 다음 수가 d+1, d-1 올 수 있기 때문에
    3) f(N, d)를 동시에 구해야 한다. 점화식은 인자 2개도 받을 수 있다. 
    즉, f(N, d) -> f(N+1, d+1), f(N+1, d-1)
    
    ex) 
     1) 45656이 있다면 다음으로 5, 7이 올 수 있다. 
     2) 456543210이 있다면 다음으로 1만 올 수 있다. 
     3) 789가 있다면 다음으로 8만 올 수 있다.
     즉, 1~8부터는 +1, -1이 가능하고 0은 +1, 9는 -1이 된 수만 올 수 있다.
     
     ### 점화식
     f(N, d) := 길이가 n이고 마지막 수가 d인 계단수 개수
     
    (f(N, 0) + f(N, 1) + f(N, 2) + ... + f(N, 9)) % MOD 가 답
      
     점화식 f(N, d) = f(N-1, d-1) + f(N-1, d+1)
    (단, d가 0혹은 9일 경우 하나만 적용)  
     
'''

MOD = 1_000_000_000
# dp[n][d]: 길이가 n, 마지막 숫자가 d인 계단 수
dp = [[0] * 10 for _ in range(101)]

# 초기화 (N=1인 경우 모든 경우에 대한 계단수가 1개만 존재)
for i in range(1, 10):
    dp[1][i] = 1

for i in range(2, 101):
    for j in range(10):

        # 끝자리가 0혹은 9라면 조건문을 타고
        # 아니라면 모든 조건문을 탄다.
        if j > 0:
            dp[i][j] += dp[i - 1][j - 1]
            dp[i][j] %= MOD

        if j < 9:
            dp[i][j] += dp[i - 1][j + 1]
            dp[i][j] %= MOD

# 점화식 계산

# 다 더하면 모든 수에 대한 계단수를 구할 수 있음
ans = 0
for j in range(10):
    ans += dp[N][j]
    ans %= MOD

print(ans)
