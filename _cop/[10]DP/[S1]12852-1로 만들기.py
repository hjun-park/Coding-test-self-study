import sys

input = sys.stdin.readline

N = int(input().rstrip())  # 수 입력

d = [0] * (N + 2)  # dp 함수 정의
pre = [0] * (N + 2)  # 이전 수 추적 용도


def logic():
    for i in range(2, N + 1):   # 2부터 돌기 시작
        d[i] = d[i - 1] + 1     # 1을 뺀 값의 최소 연산 횟수 대입
        pre[i] = i - 1          # 자신의 배열에 연산을 적용한다면 올 다음 값 (1을 뺀 값)을 추가

        # 1. 3으로 나눠지며 연산횟수가 1을 뺀 것보다 더 적다면
        if i % 3 == 0 and d[i // 3] + 1 < d[i]:
            # 1. 3으로 나눌 경우 최소 연산 횟수 대입
            d[i] = d[i // 3] + 1
            # 2. 자신의 배열에 연산을 적용한다면 올 다음 값 (3으로 나눈 값)을 추가
            pre[i] = i // 3

        # 2. 2로 나눠지며 연산횟수가 1을 뺸 것보다 더 적다면
        if i % 2 == 0 and d[i // 2] + 1 < d[i]:
            # 1. 2로 나눌 경우 최소 연산 횟수 대입
            d[i] = d[i // 2] + 1
            # 2. 자신의 배열에 연산을 적용한다면 올 다음 값 (2로 나눈 값)을 추가
            pre[i] = i // 2


logic()
print(d[N])
cur = N
while True:
    # 1. 자기 자신 먼저 출력하고 1이 아니라면 계속
    print(cur, end=' ')
    if cur == 1:
        break

    # 2. 자기 자신 배열을 참조하면 가장 최소 연산으로 만들 수 있는 수가 들어 있음 (추적)
    cur = pre[cur]
